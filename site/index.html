<!DOCTYPE html>
<meta charset="utf-8">
<title>Linked Amarna</title>
<style>
body {
  overflow:hidden;
   margin:0;
}

text {
  font-family: sans-serif;
  pointer-events: none;
}

.margin {
  width: 15%;
  background-color: #f1f1f1;
  position:fixed;
}

ul {

  list-style-type: none;
  margin: 0;
  padding: 0;
  width: 15%;
  background-color: #f1f1f1;
  height: 100%;
  position: fixed;
  overflow: auto;
}

li a {
  display: block;
  color: #000;
  padding: 8px 16px;
  text-decoration: none;
}

li a:hover {
  background-color: #555;
  color: white;
}
.autocomplete {
  position: relative;
  display: inline-block;
}

input {
  border: 1px solid transparent;
  background-color: #f1f1f1;
  padding: 10px;
  font-size: 16px;
}

input[type=text] {
  background-color: #f1f1f1;
  width: 100%;
}

.autocomplete-items {
  position: absolute;
  border: 1px solid #d4d4d4;
  border-bottom: none;
  border-top: none;
  z-index: 99;
  /*position the autocomplete items to be the same width as the container:*/
  top: 100%;
  left: 0;
  right: 0;
}

.autocomplete-items div {
  padding: 10px;
  cursor: pointer;
  background-color: #fff; 
  border-bottom: 1px solid #d4d4d4; 
}

/*when hovering an item:*/
.autocomplete-items div:hover {
  background-color: #e9e9e9; 
}

/*when navigating through the items using the arrow keys:*/
.autocomplete-active {
  background-color: DodgerBlue !important; 
  color: #ffffff; 
}

.footer-container {
  position: fixed;
  bottom: 0;
  right: 0;
  width: 25%;
}
.collapsible-footer {
  color: white;
  cursor: pointer;
  border: none;
  background-color: #777;
  text-align: center;
  font-size: 15px;
  width: 100%;
}

.active, .collapsible-footer:hover {
  background-color: #555;
}

.content {
  word-wrap: break-word;
  padding: 18px;
  display: none;
  overflow-wrap: normal;
  width: 100%;
  background-color: #f1f1f1;
}

.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
}

 .slider:before {
   position: absolute;
   content: "";
   height: 26px;
   width: 26px;
   left: 4px;
   bottom: 4px;
   background-color: white;
   -webkit-transition: .4s;
   transition: .4s;
 }

 input:checked + .slider {
   background-color: #555;
 }

 input:focus + .slider {
   box-shadow: 0 0 1px #2196F3;
 }

 input:checked + .slider:before {
   -webkit-transform: translateX(26px);
   -ms-transform: translateX(26px);
   transform: translateX(26px);
 }

 .slider.round {
   border-radius: 34px;
 }

 .slider.round:before {
   border-radius: 50%;
 }




</style>
<body>
  <script src='graph4.js'></script>
  <div class='margin' id='left-margin'>
    <h1> <a href='/linked-amarna' style="color:#202020;text-decoration:none">Linked Amarna </a></h1>
    <div class='autocomplete'>
      <input type='text' style='width:90%;' placeholder="Search..." id='search-box'>
    </div>
    <ul id="listOfNames">
    </ul>
  </div>
  <div class='svg-container'>
    <svg width="960" height="600"></svg>
  </div>
  <div style="position:absolute;top:0;right:0;"> 
    <label class="switch">
      <input type="checkbox" id='fof-toggle'>
      <span title="Display Friend of a Friend Relationships" class="slider round"></span>
    </label>
  </div>
  <div class='footer-container'>
  <button type="button" class="collapsible-footer" id='select-node-info'></button>
    <div class='content'>
    </div>
  </div>
  <script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/d3-selection-multi.v1.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.js"></script>
  <script type="text/javascript">

  const width = window.innerWidth;
  const height = window.innerHeight;
  const r = 6;

  let nodes = [...baseNodes]
  let links = [...baseLinks]
  const alphabet = [
      ' ', '-', 'ʿ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'ḫ', 
      'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 
      'q', 'r', 's', 'ṣ', 'š', 't', 'ṭ', 'u', 'v', 'w', 
      'x', 'y', 'z'];

  const fof = document.getElementById('fof-toggle');

  const orderedNodes = baseNodes.sort((a, b) => {
    const a_array = [];
    const b_array = [];
      
    for (const c of a.canonical_name.toLowerCase()) {
      a_array.push(alphabet.indexOf(c));
    }
    for (const c of b.canonical_name.toLowerCase()) {
      b_array.push(alphabet.indexOf(c));
    }


    if (a_array[0] === b_array[0]) {
      return a_array[1] < b_array[1] ? -1 : a_array[1] > b_array[1] ? 1 : 0
    }

    if (a_array[0] < b_array[0]) {
      return -1
    }
    if (a_array[0] > b_array[0]) {
      return 1
    }
    return 0
  });

  const svg = d3.select('svg')
    .attr('width', width)
    .attr('height', height) 

  let linkElements, 
    nodeElements,
    textElements

  let selectedId

  const linkGroup = svg.append('g').attr('class', 'links')
  const nodeGroup = svg.append('g').attr('class', 'nodes')
  const textGroup = svg.append('g').attr('class', 'texts')

  const linkForce = d3.forceLink() //('link', d3.forceLink()
    .id(link => {return link.name_id})
    .distance(200)
    .strength(1)

  const simulation = d3.forceSimulation()
    .force('link', linkForce)
    .force('charge', d3.forceManyBody().strength(-120))
    .force('center', d3.forceCenter(width / 2, height / 2)) 

  const dragDrop = d3.drag().on('start', (node) => {
    node.fx = node.x;
    node.fy = node.y;
  }).on('drag', (node) => {
    simulation.alphaTarget(0.7).restart()
    node.fx = d3.event.x;
    node.fy = d3.event.y;
  }).on('end', (node) => {
    if (!d3.event.active) {
      simulation.alphaTarget(0)
    }
    node.fx = null
    node.fy = null
  });

  const languageObject = {
      'Akkadian': 
        {'highlighted': 'darkblue', 
        'normal': 'powderblue'},
      'Anatolian': 
        {'highlighted': 'darkred',
        'normal': 'lightred'},
      'Unknown': 
        {'highlighted': 'black', 
        'normal': 'grey'},
      'Egyptian': 
        {'highlighted': 'darkgoldenrod',
        'normal': 'lightgoldenrodyellow'},
      'Hurrian':
        {'highlighted': 'rebeccapurple', 
        'normal': 'plum'},
      'WS':
        {'highlighted': 'darkgreen',
        'normal': 'lightgreen'},
      'Indo-Iranian':
        {'highlighted': 'orange',
        'normal': 'lightsalmon'}
  }

  function getNodeColor(node, neighbors) {
    if (neighbors.indexOf(node.name_id)) {
      return languageObject[node.language]['highlighted']
    }
    return languageObject[node.language]['normal']
  }

  function getNeighbors(node) {
    return baseLinks.reduce((neighbors, link) => {
      if (link.target.name_id === node.name_id) {
        neighbors.push(link.source.name_id)
      } else if (link.source.name_id === node.name_id) {
        neighbors.push(link.target.name_id)
      }
      return neighbors
    }, [node.name_id])
  }

  function getNodeSize(node) {
    if (node.hits < 10) {
       return 5;
     }
     if (node.hits >= 10 && node.hits <= 30) {
           return 10;
     }
     if (node.hits > 30) {
       return 15;
     }
  }

  function getTextColor(node, neighbors) {
    return (Array.isArray(neighbors) && neighbors.indexOf(node.name_id) > -1) ? 'red' : 'grey'
  }

  function getLinkColor(node, link) {
    return isNeighborLink(node, link) ? 'green' : '#E5E5E5'
  }

  function isNeighborLink(node, link) {
    return link.target.name_id === node.name_id || link.source.name_id === node.name_id
  }

  function updateInfoBox(node) {
    const {language, canonical_name, scope_note, variants, occurances} = node;
    const heading = document.getElementById('select-node-info')
    heading.classList.toggle('active');
    heading.innerHTML = canonical_name;
    const content = heading.nextElementSibling;
    const langP = document.createElement('p')
    langP.innerHTML = `<b>Language:</b> ${language}`
    const scopeP = document.createElement('p')
    scopeP.innerHTML = `<b>Scope Note:</b> ${scope_note}`
    const variantP = document.createElement('p');
    const varString = variants.join(', ');
    variantP.innerHTML = `<b>Variants:</b> ${varString}`
    const occurancesP = document.createElement('p');
    const occuranceString = occurances.join(', ');
    occurancesP.innerHTML = `<b>Occrances:</b> ${occuranceString}`
    for (const ele of [scopeP, langP, variantP, occurancesP]) {
      content.appendChild(ele);
    }
  }

  function cleanInfoBox() {
    const heading = document.getElementById('select-node-info')
    heading.innerHTML = null;
    const content = heading.nextElementSibling;
    while (content.hasChildNodes()) {
      content.removeChild(content.firstChild);
    }
  }

  function selectNode(selectedNode) {
    if (selectedId === selectedNode.name_id) {
      selectedId = undefined;
      resetData();
      updateSimulation();
      cleanInfoBox();
    } else {
      cleanInfoBox();
      selectedId = selectedNode.name_id;
      updateData(selectedNode)
      updateSimulation()
      updateInfoBox(selectedNode)
    }
    const neighbors = getNeighbors(selectedNode);
    nodeElements
      .attr('fill', node => getNodeColor(node, neighbors))
    textElements
      .attr('fill', node => getTextColor(node, neighbors))
    linkElements
      .attr('stroke', link => getLinkColor(selectedNode, link))
  }

  function resetData() {
    const nodeIds = nodes.map((node) => { return node.name_id})

    baseNodes.forEach((node) => {
      if (nodeIds.indexOf(node.name_id) === -1) {
        nodes.push(node)
      }
    })

    links = baseLinks
  }

  function friendOfFriends(neighbors) {
    const extendedNeighbors = [];
    for (const neighbor of neighbors) {
      const neighborNode = baseNodes.find((x) => x.name_id === neighbor)
      const fof = getNeighbors(neighborNode);
      extendedNeighbors.push(...fof)
    }
    return extendedNeighbors
  }

  function updateData(selectedNode) {
    const fof = document.getElementById('fof-toggle');
    let neighbors = getNeighbors(selectedNode);
    links = baseLinks.filter((link) => {
      if (fof.checked) {
        return neighbors.includes(link.target.name_id) || 
          neighbors.includes(link.source.name_id)
      }
      return neighbors.includes(link.target.name_id) && 
        neighbors.includes(link.source.name_id)
    });
    if (fof.checked) {
      neighbors = friendOfFriends(neighbors);
    }
    const newNodes = baseNodes.filter((node) => {
      return neighbors.indexOf(node.name_id) > -1
    });

    const diff = {
      removed: nodes.filter(node => newNodes.indexOf(node) === -1),
      added: newNodes.filter(node => nodes.indexOf(node) === -1),
    }

    diff.removed.forEach((node) => nodes.splice(nodes.indexOf(node), 1))
    diff.added.forEach((node) => nodes.push(node))
  }


  function updateGraph() {
    // links 
    linkElements = linkGroup.selectAll('line')
      .data(links, (link) => {
        return link.target.name_id + link.source.name_id
      })

    linkElements.exit().remove()

    let linkEnter = linkElements
      .enter().append('line')
      .attr('stroke-width', 1)
      .attr('stroke', 'rgba(50, 50, 50, 0.2)')

    linkElements = linkEnter.merge(linkElements) 

    //nodes 
    nodeElements = nodeGroup.selectAll('circle')
      .data(nodes, (node) => {return node.name_id})

    nodeElements.exit().remove()

    let nodeEnter = nodeElements
      .enter()
      .append('circle')
      .attr('r', (d) => {return getNodeSize(d)})
      .attr('fill', (x) => { return languageObject[x.language]['normal']}) 
      .call(dragDrop)
      .on('click', selectNode) 

    nodeElements = nodeEnter.merge(nodeElements)
    

    //texts 
    textElements = textGroup.selectAll('text')
      .data(nodes, (node) => {return node.name_id})

    textElements.exit().remove()

    let textEnter = textElements
      .enter()
      .append('text')
      .text(node => node.canonical_name)
      .attr('font-size', 15)
      .attr('dx', 15)
      .attr('dy', 4)

    textElements = textEnter.merge(textElements)

 }

  fof.addEventListener('click', function (e) {
    if (selectedId) {
      const selectedNode = baseNodes.find((x) => x.name_id === selectedId)
      updateData(selectedNode);
    }
    updateSimulation();
  });


 function updateSimulation() {
   updateGraph()

   simulation.nodes(nodes).on('tick', () => {
    nodeElements 
       .attr('cx', (d) => {return d.x = Math.max(r, Math.min(width - r, d.x));})
       .attr('cy', (d) => {return d.y = Math.max(r, Math.min(height - r, d.y)); });
      //.attr('cx', function (node) { return node.x })
      //.attr('cy', function (node) { return node.y })
    textElements 
      .attr('x', function (node) { return node.x})
      .attr('y', function (node) { return node.y })
    linkElements
      .attr('x1', link => link.source.x)
      .attr('y1', link => link.source.y)
      .attr('x2', link => link.target.x)
      .attr('y2', link => link.target.y)
   })

   simulation.force('link').links(links)
   simulation.alphaTarget(0.2).restart()
 }

  function nameChooserFromLink(node) { 
    selectedId = undefined;
    selectNode(node);
  }

 function createUlElement() {
   const ulEle = document.getElementById('listOfNames')
   for (const node of orderedNodes) {
     const liEle = document.createElement('li');
     liEle.id = node.name_id;
     const a = document.createElement('a')
     a.onclick = () => {selectNode(node)};
     a.innerHTML = node.canonical_name;
     liEle.append(a);
     ulEle.append(liEle);
   }
 }

// Fuse settings 

const options = {
  isCaseSensitive: false,
  findAllMatches: false,
  includeMatches: false,
  includeScore: false,
  useExtendedSearch: false,
  minMatchCharLength: 1,
  shouldSort: true,
  threshold: 0.6,
  location: 0,
  distance: 100,
  keys: [
    "canonical_name",
    "variants"
  ]
};

const fuse = new Fuse(variants, options);

function autocomplete(inp) {
  let currentFocus;
  inp.addEventListener('input', function(e) {
    let a, b, i, val = this.value;
    closeAllLists();
    if (!val) { return false;}
    currentFocus = -1;
    a = document.createElement('div');
    a.setAttribute('id', this.id + 'autocomplete-list');
    a.setAttribute('class', 'autocomplete-items')
    this.parentNode.appendChild(a);
    let matches = fuse.search(val);
    for (const match of matches) {
      b = document.createElement('div');
      b.innerHTML = match.item.variant;
      b.id = match.item.name_id
      b.addEventListener('click', function(e) {
        let sel_value = this.id;
        const node = baseNodes.find((x) => x.name_id == sel_value)
        selectNode(node);
        closeAllLists()
      });

      a.appendChild(b)
    }
  });

  inp.addEventListener('keydown', function(e) {
    let x = document.getElementById(this.id + 'autocomplete-list');
    if (x) x = x.getElementsByTagName('div');
    if (e.keyCode == 40) {
      currentFocus++;
      addActive(x);
    } else if (e.keyCode == 38) {
      currentFocus--;
      addActive(x);
    } else if (e.keyCode == 13) {
      e.preventDefault();
      if (currentFocus > -1) {
        if (x) x[currentFocus].click();
      }
    }
  });
  function addActive(x) {
    if (!x) return false;
    removeActive(x);
    if (currentFocus >= x.length) currentFocus = 0;
    if (currentFocus < 0) currentFocus = (x.length - 1);
    x[currentFocus].classList.add('autocomplete-active');
  }
  function removeActive(x) {
    for (let i = 0; i < x.length; i++) {
       x[i].classList.remove('autocomplete-active');
    }
  }
  function closeAllLists(elmnt) {
    let x = document.getElementsByClassName('autocomplete-items');
    for (let i = 0; i < x.length; i++) {
      if (elmnt != x[i] && elmnt != inp) {
        x[i].parentNode.removeChild(x[i]);
      }
    }
  }
  document.addEventListener('click', function(e) {
    closeAllLists(e.target);
  });
}

// footer

const colls = document.getElementsByClassName('collapsible-footer');

  

for (let i = 0; i < colls.length; i++) { 
    colls[i].addEventListener('click', () => {
      colls[i].classList.toggle('active');
      let content = colls[i].nextElementSibling;
      if (content.style.display === 'block') {
        content.style.display = 'none';
      } else {
        content.style.display = 'block';
      }
    });
}


autocomplete(document.getElementById('search-box'));
createUlElement()
updateSimulation()

</script>
</body>
